# 离散集合的距离度量函数设计

![1](http://latex.codecogs.com/svg.latex?\int_a^bf(x)\ dx)

## 原始问题

对于集合D={{a, b, c, d}，可行的排列可能性个数为A_4^4。例如：
$$
    A_0=\{a, b, c, d\},A_1=\{b, a, d, c\}，A_2=\{d, c, b, a\},...
$$

- 现求一个对元素位置的度量函数
  $$
  f(A_x)
  $$
  满足条件：
  $$
  f(A_m)-f(A_n)=[f(A_m)-f(A_0)] - [f(A_n)-f(A_0)]
  $$
  要求具有唯一性。

## 解决方案

### 原始方案

- 定义一个基准排列，利用**逆序数**的概念体现查询排列和基准排列的差异。

  其直接体现可以是使用冒泡排序的方式，将查询排列排序成基准排列时候需要交换的次数。

- 存在问题：**碰撞导致的不唯一性**。

### 改进思路

碰撞导致的逆序数不唯一性的解决，可以通过**使代价函数单调化**来解决。

观察当N=5时候，逆序数的变化：每2个点出现一次平值，每6个点出现一次下降，每24个点出现一次突降


### 改进方案1：排序成本：让**交换不同元素时产生的代价不同**。

把位置和基排列不一致的元素命名为**逆子w(weight)**；

把所有逆子放回到正确的位置上所需的操作次数命名为**逆数s(step)**

于是定义排序成本***cost***满足计算公式
$$
cost=∑\vec{w}×\vec{s}
$$
从做功的角度考虑其物理意义为”**把<u>所有</u>逆子放回到正确的位置上所需做的功**=逆子数（质量）×逆数（距离）”

```
例如：序列A：{1,2,5,4,3,6} (其逆序数为3)
        第1个逆子为5,交换5到正确的位置需要2步，故cost=5*2=10；
        第2个逆子为4,交换4到正确的位置需要1步，故cost=1*4=4;
        没有更多的逆子，所以该序列的cost(A)=10+4=14
	序列A：{2,1,4,3,6,5} (其逆序数也为3)
        第1个逆子为2,交换2到正确的位置需要1步，故cost=1*2=2；
        第2个逆子为4,交换4到正确的位置需要1步，故cost=1*4=4;
        第2个逆子为6,交换6到正确的位置需要1步，故cost=1*6=6;
		没有更多的逆子，所以该序列的cost(B)=2+4+6=12
可以将这两种情况加以区分
```


此时做功数仍然会冲突：比如让2走3步和让6走1步的代价值相同。

这是由于做功函数F对于距离s和质量w都是线性函数导致的。所谓线性，即齐次性和可加性：

$$
F(k_1w_1+ k_2w_2, k_3s_1+ k_4s_2)\\
=F(k_1w_1,k_3s_1)+F(k_1w_1,k_4s_2)+F(k_2w_2,k_3s_1)+F(k_2x_2,k_4s_2)\\
=k_1k_3F(w_1,s_1)+k_1k_4F(w_1,s_2)+k_2k_3F(w_2,s_1)+k_2k_4F(x_2,s_2)
$$

所以设法构造一个非线性函数g(w)便可解决这一问题。于是改进后的cost就变成了

$$
cost=∑\vec{g(w)}×\vec{s}
$$

尝试使用**指数函数**设计逆子质量w非线性函数g(w)：
$$
g(w)=1+exp(w)\\
$$
验证发现，这样能够消除重复，但是对于越大的w值，非线性变换后值会过大。具体而言，会导致让6走一步的代价比让5走一步的代价大太多。所以g(w)最好是有周期的。所以尝试使用**三角函数**设计，调节参数使其周期为集合长度N。为满足非负性，后加offset=1.
$$
g(w)=1+sin(\frac{2π}{N}w)\\
$$


验证发现，这样虽然能够解决非线性变换后值过大的问题，但距离差异不够明晰，精度不高的时候可能会有duplicate。二者各有利弊。

但是 不满足三角形不等式啊啊啊啊啊啊所以我暴力输出一波，弄一个系数向量
$$
\overrightarrow{a}=[a_0,a_1,a_2,a_3,a_4]
$$
然后直接写一个终于写对了的公式，让
$$
g(w) = \overrightarrow{a}*[1,w,w^2,w^3,w^4]^T\\=a_0+a_1w+a_2w^2+a_3w^3+a_4w^4 
$$
穷举法试不同的a向量找一个满足两个条件的不等式！等一两天，希望能够找到一个准确的结果！



#### 总结

1. 该方案确实能够实现对离散变量之间计算距离，并有效避免了一对多时的值碰撞问题；
2. 对w的非线性变换实际上是一个加权的过程，可以根据具体问题中的实际意义再构建g(w)

#### 附1.三个元素时的距离矩阵（使用指数函数计算）

![image-20210127231036248](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210127231036248.png)

#### 附2.代码实现

```python
"""
    计算枚举型离散变量的类距离DiscreteDistance
"""
import math
from itertools import permutations

def getDiscreteDistance(_arr1, _arr2, _size):
    """
    在传进来一套排列的集合之后，默认第一个排列为基，对应将各个元素编码为1,2,3,4,5...
    然后再计算由数字确定的逆序数,变换得到DiscreteDistance
    :param _arr1:   离散集合1
    :param _arr2:   离散集合2
    :param _size:   确定一下集合的大小
    :return: 返回计算得到的两个集合的距离
        todo: 对逆序数做唯一性处理，使得在一个全排列上
    """
    DiscreteDistance = 0
    kvDictList = []
    # 将_arr1的顺序定义为1,2,3,4..._size，构造字典列表
    for i in range(0, _size):
        kvDictList.append({'item': _arr1[i], 'num': i})
    # 按照kvDict里的对应方式把_arr2里的翻译成0,3,1,4,2，记录到tar[]里
    tar = []
    for i in range(0, _size):
        # 查找arr2中第i个元素在kvDictList的对应的位置
        for j in range(0, _size):
            # 找到了就把这个字母对应的数字抄写到tar中
            if _arr2[i] == kvDictList[j]['item']:
                tar.append(kvDictList[j]['num'])
    DiscreteDistance = getInverse(tar)
    return DiscreteDistance


def getInverse(arr):
    """
        利用逆序数计算排序成本cost, cost=∑逆数×逆子

    :param arr: 传进来的一个离散集合
    :return: 返回计算的cost值
    """
    cost = 0
    for i in range(len(arr)):
        step = 0
        for j in range(i):
            if arr[j] > arr[i]:
                # result += 1			#	这就是一般的逆序数求解
                # cost += math.sin(2*3.1415*arr[j]/len(arr))+1
                # 通过累加实现乘法
                cost += math.exp(arr[j])#	这里采用的是第一种g(w)
                
    return cost
```



**完了**

**2020年1月27日**

-------------------------------------------------------------------------------

### 改进方案2（失败了）：利用逆序数设计构造单调的代价函数（单调变换）

- 先整体乘以2（为下一步的加1避免冲突做准备）
  $$
  cost(i)=2*inverse(i)
  $$

- 平值点：当i为偶数时且i不是6的整数倍：在此时的cost基础上加1
  $$
  cost(i)=cost(i-1)+1,i=2*k(k=0,1,2)and (i) mod (N-1)≠0
  $$
  ![image-20210127145817323](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210127145817323.png)

- 突降点：i是24的整数倍时候会有突降，这时候将在将cost值+6*(i÷6)
  $$
  cost=inverse(i)+6*(i÷6), when(i) mod (24)=0
  $$
  ![image-20210127153339069](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20210127153339069.png)

- 但是这还是有冲突，这个解法放弃了555。


-------------------------------------------------------------------------------
